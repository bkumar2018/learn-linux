
1. stdout (standard out)

echo Hello World > peanuts.txt

The > is a redirection operator that allows us to change where standard output goes. It allows us to send the output of echo Hello World to a file instead of the screen. 

echo Hello World >> peanuts.txt

Well, let's say I didn't want to overwrite my peanuts.txt. 
Luckily, there is a redirection operator for that as well: >>.

2. stdin (standard In)

cat < peanuts.txt > banana.txt

Just like we had > for stdout redirection, we can use < for stdin redirection.

Normally, in the cat command, you send a file to it and that file becomes the stdin. In this case, we redirected peanuts.txt to be our stdin. Then the output of cat peanuts.txt, which would be "Hello World", gets redirected to another file called banana.txt.

3. stderr (standard error)

ls /fake/directory 2> peanuts.txt

ls /fake/directory > peanuts.txt 2>&1

ls /fake/directory &> peanuts.txt


Unfortunately, the redirector is not as nice as using < or > but it's pretty close. We will have to use file descriptors. A file descriptor is a non-negative number that is used to access a file or stream. We will go in depth about this later, but for now know that the file descriptor for stdin, stdout, and stderr is 0, 1, and 2 respectively.


ls /fake/directory 2> /dev/null

Now what if I don't want any of that cruft and want to get rid of stderr messages completely? Well, you can also redirect output to a special file called /dev/null and it will discard any input.


4 . pipe and tee 

ls -la /etc

ls -la /etc | less

The pipe operator |, represented by a vertical bar, allows us to get the stdout of a command and make that the stdin to another process. In this case, we took the stdout of ls -la /etc and then piped it to the less command. The pipe command is extremely useful, and we will continue to use it for all eternity.


ls | tee peanuts.txt

You should see the output of ls on your screen, and if you open up the peanuts.txt file, you should see the same information!


5. env (Environment)

echo $HOME
echo $USER

Where is this information coming from? 
It's coming from your environment variables. 
You can view these by typing:

env

$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/bin

This returns a list of paths separated by a colon that your system searches when it runs a command. Let's say you manually download and install a package from the internet and put it into a non-standard directory, and you want to run that command. You type $ coolcommand, and the prompt says "command not found." Well, that's silly; you are looking at the binary in a folder and know it exists. What is happening is that the $PATH variable doesn't check that directory for this binary, so it's throwing an error.

Let's say you had tons of binaries you wanted to run out of that directory; you can just modify the PATH variable to include that directory in your PATH environment variable.


6. cut 

echo 'The quick brown; fox jumps over the lazy  dog' > sample.txt

To extract contents by a list of characters:

cut -c 5 sample.txt. --- 'q' is output


cut -f 1 -d ";" sample.txt

The -f or field flag cuts text based on fields. By default, it uses TABs as delimiters, so everything separated by a TAB is considered a field. You should see "dog" as your output.
This will change the TAB delimiter to a ";" delimiter, and since we are cutting the first field, the result should be "The quick brown".

8. head 

head /var/log/syslog

By default, the head command will show you the first 10 lines in a file.

head -n 15 /var/log/syslog

9. tail

tail /var/log/syslog
tail -n 10 /var/log/syslog

tail -f /var/log/syslog

Another great option you can use is the -f (follow) flag; this will follow the file as it grows. Give it a try and see what happens.
Your syslog file will be continually changing while you interact with your system, and using tail -f you can see everything that is getting added to that file.


13. tr (Translate)
The tr (translate) command allows you to translate one set of characters into another set of characters. Let's try an example of translating all lowercase characters to uppercase characters.

$ tr a-z A-Z
hello
HELLO
As you can see, we made the ranges of a-z into A-Z, and all text we type that is lowercase gets uppercased.


15. wc and nl
The wc (word count) command shows the total count of words in a file.

$ wc /etc/passwd
 96     265    5925 /etc/passwd
It displays the number of lines, number of words, and number of bytes, respectively.

To see just the count of a certain field, use the -l, -w, or -c options, respectively.

$ wc -l /etc/passwd
96


16. grep

grep fox sample.txt

You should see that grep found "fox" in the sample.txt file.

You can also grep patterns that are case-insensitive with the -i flag:

grep -i fox sample.txt

grep -i somepattern somefile

env | grep -i User

ls /somedir | grep '.txt$'

This should return all files ending with .txt in somedir.



